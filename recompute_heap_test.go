package incr

import (
	"testing"
)

func Test_recomputeHeap_RemoveMin(t *testing.T) {
	rh := newRecomputeHeap(32)

	n00 := newHeightIncr(0)
	n01 := newHeightIncr(0)
	n10 := newHeightIncr(1)
	n100 := newHeightIncr(10)

	rh.Add(n00)
	ItsEqual(t, 1, rh.Len())
	ItsEqual(t, 32, len(rh.heights))
	ItsEqual(t, 1, rh.heights[0].len)
	rh.Add(n01)
	ItsEqual(t, 2, rh.Len())
	ItsEqual(t, 32, len(rh.heights))
	ItsEqual(t, 2, rh.heights[0].len)

	ItsEqual(t, 0, rh.minHeight)
	ItsEqual(t, 0, rh.maxHeight)

	rh.Add(n10)
	ItsEqual(t, 3, rh.Len())
	ItsEqual(t, 32, len(rh.heights))
	ItsEqual(t, 2, rh.heights[0].len)
	ItsEqual(t, 1, rh.heights[1].len)
	ItsEqual(t, 0, rh.minHeight)
	ItsEqual(t, 1, rh.maxHeight)

	rh.Add(n100)
	ItsEqual(t, 4, rh.Len())
	ItsEqual(t, 32, len(rh.heights))
	ItsEqual(t, 2, rh.heights[0].len)
	ItsEqual(t, 1, rh.heights[1].len)
	ItsEqual(t, 1, rh.heights[10].len)
	ItsEqual(t, 0, rh.minHeight)
	ItsEqual(t, 10, rh.maxHeight)

	r00 := rh.RemoveMin()
	ItsNotNil(t, r00)
	ItsNotNil(t, r00.Node())
	ItsEqual(t, n00.n.id, r00.Node().id)
	ItsEqual(t, 3, rh.Len())
	ItsEqual(t, false, rh.Has(n00))
	ItsEqual(t, true, rh.Has(n01))
	ItsEqual(t, true, rh.Has(n10))
	ItsEqual(t, true, rh.Has(n100))
	ItsEqual(t, 1, rh.heights[0].len)
	ItsEqual(t, 1, rh.heights[1].len)
	ItsEqual(t, 1, rh.heights[10].len)
	ItsEqual(t, 0, rh.minHeight)
	ItsEqual(t, 10, rh.maxHeight)

	r01 := rh.RemoveMin()
	ItsNotNil(t, r01)
	ItsNotNil(t, r01.Node())
	ItsEqual(t, n01.n.id, r01.Node().id)
	ItsEqual(t, 2, rh.Len())
	ItsEqual(t, false, rh.Has(n00))
	ItsEqual(t, false, rh.Has(n01))
	ItsEqual(t, true, rh.Has(n10))
	ItsEqual(t, true, rh.Has(n100))
	ItsEqual(t, 0, rh.heights[0].len)
	ItsEqual(t, 1, rh.heights[1].len)
	ItsEqual(t, 1, rh.heights[10].len)
	ItsEqual(t, 1, rh.minHeight)
	ItsEqual(t, 10, rh.maxHeight)

	r10 := rh.RemoveMin()
	ItsNotNil(t, r10)
	ItsNotNil(t, r10.Node())
	ItsEqual(t, n10.n.id, r10.Node().id)
	ItsEqual(t, 1, rh.Len())
	ItsEqual(t, false, rh.Has(n00))
	ItsEqual(t, false, rh.Has(n01))
	ItsEqual(t, false, rh.Has(n10))
	ItsEqual(t, true, rh.Has(n100))
	ItsEqual(t, 0, rh.heights[0].len)
	ItsEqual(t, 0, rh.heights[1].len)
	ItsEqual(t, 1, rh.heights[10].len)
	ItsEqual(t, 10, rh.minHeight)
	ItsEqual(t, 10, rh.maxHeight)

	r100 := rh.RemoveMin()
	ItsNotNil(t, r100)
	ItsNotNil(t, r100.Node())
	ItsEqual(t, n100.n.id, r100.Node().id)
	ItsEqual(t, 0, rh.Len())
	ItsEqual(t, false, rh.Has(n00))
	ItsEqual(t, false, rh.Has(n01))
	ItsEqual(t, false, rh.Has(n10))
	ItsEqual(t, false, rh.Has(n100))
	ItsEqual(t, 0, rh.heights[0].len)
	ItsEqual(t, 0, rh.heights[1].len)
	ItsEqual(t, 0, rh.heights[10].len)
	ItsEqual(t, 0, rh.minHeight)
	ItsEqual(t, 10, rh.maxHeight)
}

func Test_recomputeHeap_RemoveMinHeight(t *testing.T) {
	rh := newRecomputeHeap(10)

	n00 := newHeightIncr(0)
	n01 := newHeightIncr(0)
	n02 := newHeightIncr(0)

	n10 := newHeightIncr(1)
	n11 := newHeightIncr(1)
	n12 := newHeightIncr(1)
	n13 := newHeightIncr(1)

	n50 := newHeightIncr(5)
	n51 := newHeightIncr(5)
	n52 := newHeightIncr(5)
	n53 := newHeightIncr(5)
	n54 := newHeightIncr(5)

	rh.Add(n00)
	rh.Add(n01)
	rh.Add(n02)
	rh.Add(n10)
	rh.Add(n11)
	rh.Add(n12)
	rh.Add(n13)
	rh.Add(n50)
	rh.Add(n51)
	rh.Add(n52)
	rh.Add(n53)
	rh.Add(n54)

	ItsEqual(t, 12, rh.Len())
	ItsEqual(t, 0, rh.MinHeight())
	ItsEqual(t, 5, rh.MaxHeight())

	output := rh.RemoveMinHeight()
	ItsEqual(t, 9, rh.Len())
	ItsEqual(t, 3, len(output))
	ItsNil(t, rh.heights[0].head)
	ItsNil(t, rh.heights[0].tail)
	ItsEqual(t, 0, rh.heights[0].len)
	ItsNotNil(t, rh.heights[1].head)
	ItsNotNil(t, rh.heights[1].tail)
	ItsEqual(t, 4, rh.heights[1].len)
	ItsNotNil(t, rh.heights[5].head)
	ItsNotNil(t, rh.heights[5].tail)
	ItsEqual(t, 5, rh.heights[5].len)

	ItsEqual(t, 1, rh.MinHeight())
	ItsEqual(t, 5, rh.MaxHeight())

	output = rh.RemoveMinHeight()
	ItsEqual(t, 5, rh.Len())
	ItsEqual(t, 4, len(output))
	ItsNil(t, rh.heights[0].head)
	ItsNil(t, rh.heights[0].tail)
	ItsEqual(t, 0, rh.heights[0].len)
	ItsNil(t, rh.heights[1].head)
	ItsNil(t, rh.heights[1].tail)
	ItsEqual(t, 0, rh.heights[1].len)
	ItsNotNil(t, rh.heights[5].head)
	ItsNotNil(t, rh.heights[5].tail)
	ItsEqual(t, 5, rh.heights[5].len)

	output = rh.RemoveMinHeight()
	ItsEqual(t, 0, rh.Len())
	ItsEqual(t, 5, len(output))
	ItsNil(t, rh.heights[0].head)
	ItsNil(t, rh.heights[0].tail)
	ItsEqual(t, 0, rh.heights[0].len)
	ItsNil(t, rh.heights[1].head)
	ItsNil(t, rh.heights[1].tail)
	ItsEqual(t, 0, rh.heights[1].len)
	ItsNil(t, rh.heights[5].head)
	ItsNil(t, rh.heights[5].tail)
	ItsEqual(t, 0, rh.heights[5].len)

	rh.Add(n50)
	rh.Add(n51)
	rh.Add(n52)
	rh.Add(n53)
	rh.Add(n54)

	ItsEqual(t, 5, rh.Len())
	ItsEqual(t, 5, rh.MinHeight())
	ItsEqual(t, 5, rh.MaxHeight())

	output = rh.RemoveMinHeight()
	ItsEqual(t, 0, rh.Len())
	ItsEqual(t, 5, len(output))
	ItsNil(t, rh.heights[0].head)
	ItsNil(t, rh.heights[0].tail)
	ItsEqual(t, 0, rh.heights[0].len)
	ItsNil(t, rh.heights[1].head)
	ItsNil(t, rh.heights[1].tail)
	ItsEqual(t, 0, rh.heights[1].len)
	ItsNil(t, rh.heights[5].head)
	ItsNil(t, rh.heights[5].tail)
	ItsEqual(t, 0, rh.heights[5].len)
}

func Test_recomputeHeapList_popAll(t *testing.T) {
	n0 := newHeightIncr(0)
	n1 := newHeightIncr(0)
	n2 := newHeightIncr(0)

	rhl := new(recomputeHeapList)
	rhl.push(n0)
	rhl.push(n1)
	rhl.push(n2)

	ItsNotNil(t, rhl.head)
	ItsNotNil(t, rhl.tail)
	ItsEqual(t, 3, rhl.len)

	output := rhl.popAll()
	ItsEqual(t, 3, len(output))
	ItsEqual(t, 0, rhl.len)
	ItsNil(t, rhl.head)
	ItsNil(t, rhl.tail)
}
